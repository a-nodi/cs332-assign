# Summery of The mythical man-month
```
이 글은 프레더릭 브룩스 2세의 맨먼스 미신의 요약이다.
```

## Chapter 1: 진흙 구덩이

```
"숱한 노력들이 빠져나오려 몸부림치는 진흙 구덩이이면서도 동시에 모든 기쁨과 고뇌가 함께하는 창조적인 행위, 바로 이것이 프로그램 작업이다."
```

### 프로그래밍 시스템 제품
1. 프로그램
```
프로그램은 자체로 완결적이다.
생산성 추측 대상으로 사용한다.
```

2. 프로그래밍 제품 
```
누구나 실행/테스트/수리/확장할 수 있는 프로그램이다.
입력 범위와 형식은 용납 가능한 선에서 최대한 일반화되어야 한다.
많은 테스트를 거쳐 신뢰성을 입증해야한다.
누구나 실행/테스트/수리/확장 가능하게끔 문서화가 이루어져야 한다.

즉, 유지관리가 될 수 있어야햔다.
```

3. 프로그래밍 시스템
```
상호작용하는 프로그램들의 집합이다.
모든 입출력의 구문과 의미가 정확히 정의된 인터페이스에 들어맞도록 프로그램을 작성해야한다.
컴퓨팅 자원을 사전에 규정된 한도 안에서만 사용하도록 설계해야 한다.
무결성을 검사해야 한다.
```

4. 프로그래밍 시스템 제품
```
누구나 실행/테스트/수리/확장할 수 있는, 상호작용하는 프로그램들의 집합이다.
```

### 작업의 즐거움
마음 속 깊은 곳에 있는 창작에 대한 열망을 충족시켜주기에 프로그램 작성은 즐겁다. 
```
1. 무엇을 만든다는 순수한 즐거움
2. 다른 사람에게 쓸모 있는 뭔가를 만드는 데서 오는 즐거움
3. 서로 맞물려 돌아가는 퍼즐 같은 복잡한 객체를 멋지게 만들어내는/
   절묘한 사이클로 작동하는/
   개발 시작 당시 정했던 원칙의 결과를 지켜보는 즐거움
4. 항상 새로운 뭔가를 배운다는 즐거움
5. 다루기 쉬운 매체를 갖고 작업한다는 즐거움
```
### 작업의 고통
```
1. 작업은 완벽하게 해야 한다.
2. 목표를 설정하고, 자원을 공급하고, 정보를 제공하는 주체가 내가 아니라 다른 사람이다.
3. 야심찬 개념을 섦계하는 것은 재미있지만, 자잘한 디버깅은 단순노동에 지나지 않는다.
4. 오류 수정 작업은 작업 대비 시간 효율이 선형 또는 그 아래이다.
5. 끝끝내 만든 작업물이 다른 이의 작업물에게 완벽하게 하위호환일 수 있다.
```

## Chapter 2: 맨먼스 미신
소프트웨어 프로젝트가 실패하는 가장 흔한 이유는 일정 관리 실패이며, 아래는 일정을 맞추지 못하는 주요 원인이다.
```
1. 견적 기술이 아직 발달하지 못했다.
2. 견적 방식에서 노동력과 작업 진행관계를 혼동한다.
3. 견적 수치에 대한 확신이 없기 때문에, 소프트웨어 관리자들은 업무 진행 원칙을 지키지 못한다.
4. 일정에 따른 진행 상황을 제대로 감독하지 못한다.
5. 일정이 공전되고 있다는 것을 깨달을 때, 인력을 많이 투입하는 해결방식이다.
```

### 낙관 주의
```
시스템 프로그래밍 일정 계획의 바탕에 깔리는 첫 번째 잘못으로 모든 임무가 주어진 시간 안에 꼭 완수될 것이라는 가정이다.

대형 프로그래밍 프로젝트는 여러 임무가 유기적으로 연결되어 있으므로 모두 완벽하게 진행될 가능성은 매우 적다.
```

### 맨먼스
```
시스템 프로그래밍 일정 계획의 바탕에 깔리는 두 번째 잘못으로 인력과 기간은 상호 교환할 수 있다는 믿음이다. 이를 표한하는 단위로 맨먼스 (Man-month)가 사용된다.

커뮤니케이션으로 인한 부담: 훈련, 상호 커뮤니케이션
훈련 ∝ 작업자의 수
상호 커뮤니케이션 ∝ (작업자의 수)^2

커뮤니케이션이 필요한 분할 가능한 임무는 사람이 많을 수록 필요한 시간이 줄어들지만 (많은 사람이 들어갈수록 효율이 떨어진다)
상호관계가 복잡한 임무는 사람이 많아도 필요한 시간이 늘어날 수 있다.
```

### 시스템 테스트
```
디버깅과 시스템 테스트는 낙관주의 때문에 버그의 수를 실제보다 적게 예측하는 경향이 있어 일정 계획에 어려움을 준다.

저자는 다음과 같은 타임라인이 효과가 있다고 한다.
1/3: 계획
1/6: 코딩 작업
1/4: 디버깅과 초기 시스템 테스트
1/4: 시스템 테스트, 모든 컴포넌트 입수

시스템 테스트는 후반에 이루어지니, 여기서 예상치 못한 문제가 일어나면 프로젝트 막바지에 제품 납기에 문제 있음을 알리게 되므로 시스템 테스트에는 넉넉한 시간을 할애해야한다.
```

### 비겁한 견적
```
고객이 프로그래밍 제품에 독촉을 한다고 해서 완벽한 제품이 빠르게 납기될 수 없다. 완벽하지 못한 제품을 기한 안에 납기하거나, 당겨진 납기일을 지키지 않는 선택지 밖에 없다.

이런 일이 일어나지 않도록 버그 발생 수치, 견적 규칙 등 생산성 수치를 개발하여 일정 계획에 근거를 제공해야한다.
```

### 되풀이되는 일정 참사 
```
일정이 늦어진 소프트웨어 프로젝트에 인력을 추가하는 것은 일정을 더욱 늦추는 결과를 낳을 뿐이다.

이것은 맨먼스의 미신을 깨뜨리는 발언이다.

일정을 정할때에는 사람 숫자를 되도록 줄이고 일정을 최대한 늘려 잡아야한다.
```

## Chapter 3: 수술팀
"상식적인 일정 안에 대형 시스템을 구축해야 하는 경우는 어떻게 할 것인가?"라는 질문을 살펴보자.

### 문제
```
유능한 프로그래머와 어설픈 프로그래머는 생산성 차이가 매우 크다.
그렇기에 소수의 유능한 프로그래머로 짜인 팀이 다수의 어설픈 프로그래머로 짜인 팀보다 훨씬 능률이 좋지만, 
대형 프로젝트는 일정 수준의 생산량을 필요로 하기에 소수의 유능한 프로그래머팀과 다수의 어설픈 프로그래머팀 모두 프로젝트의 기한을 맞추기 힘들다.
두 팀을 조화시키는 것이 중요한 사안이다.
```

### 밀스의 제안
```
수술팀과 같이 대형 작업의 각 부분을 팀으로 나누어 처리해야한다.
아래는 수술팀의 각 역할군이다.
```

#### 외과의사
```
기능과 성능 명세 정의, 프로그램 설계, 코딩, 테스트, 문서작업이 모두 가능한 프로그래머 장이다.
```

#### 부기장
```
외과의사와 같이 모든 작업이 가능하지만 경험이 부족하며, 외과의사와 설계에 대해 토론하며 설계 오류등의 참사를 방지한다.
```

#### 행정관
```
외과의사 대신 돈과 인력, 공간, 기계, 조직등 행정적인 업무를 처리하는 사람이다.
```

#### 편집자
```
외과의사의 문서 원고를 받아 첨삭하고 관리한다.
```

#### 비서 두 명
```
행정관과 편집자가 두는 비서이다. 프로젝트 통신문과 제품 외적 파일을 처리한다.
```

#### 프로그램 사무원
```
프로그래밍-제품 라이브러리에 있는 팀의 모든 기술적 기록의 관리 책임을 지는 사람이다.
```

#### 도구 대장장이
```
팀이 필요로 하는 특수 도구들의 적절함을 보장하고 특수 도구들이 구축과 관리 그리고 업그레이드를 책임진다.
```

#### 검사원
```
시스템 테스트 케이스를 만들고 디버깅을 위한 테스트 데이터를 만들어낸다.
```

#### 언어 변호사
```
프로그래밍 언어를 깊게 사용할 줄 알아 복잡한 문제를 효과적으로 풀어내는 역할이다.
```

### 운영방식
```
수술팀은 전통적 방식으로 구성된 프로그래밍 팀(모든 사람이 평등)과 다르다.
수술팀은 전통방식의 팀에 대해 두가지 이 점이 있다.

1. 외과의사가 부기장이 코드 전체를 알고 있기 때문에 작업의 개념성 일관성을 확보할 수 있다.

2. 외과의사가 구성원의 구현 차이를 조정하기에 구성원간 이해관계가 충돌하지 않는다.
```

### 규모 확대
```
규모 확대는 수술팀을 여러 개를 꾸리면 이룰 수 있는데, 이는 외과의사들을 조율하는 것이 선행되야 한다.
설계와 구현의 차이가 명확히 있어야하며, 전체 시스템을 설계만 하는 설계자가 필요하다.
```

## Chapter 4: 귀족정치, 민주주의 그리고 시스템 설계

### 개념적 무결성
```
좋은 기능들이지만 서로 독립적이고 조화되지 못한 아이디어들을 담고 있는 시스템보다는 여러가지 기능이나 갱신된 내용은 빠졌더라도 통일된 설계 아이디어를 반영한 시스템이 훨씬 좋다.
```

### 개념적 무결성을 이루는 방법
```
주어진 기능수준에 대해서 가장 좋은 시스템은 가장 단순하고 직설적으로 명세가능하다. 
이러한 단순성과 직설성은 개념적 무결성에서 나오며, 사용의 쉬움은 설계와 개념의 무결성으로부터 나온다.
```

### 귀족 정치와 민주주의
```
설계와 구현은 명확히 구별되어야 한다. 이런 방식은 설계자들은 귀족, 구현자들은 평민이 된 구조라고 오해를 일으킬 수 있다.
민주주의적으로 구현자들이 설계에 대해 좋은 아이디어가 있다면 적용시킬 수 있으나, 이는 개념적 무결성을 해칠 수 있다.
전체 시스템 설계에는 통제를 받지만, 구현의 설계에는 통제를 받지 않기에 이는 꼭 귀족주의라고 볼 수 없다.
오히려 시스템의 설계 규제는 구현 설계의 창의성을 증진시킨다.
```

### 구현자들은 기다리는 동안 무엇을 하나
```
아키텍처, 구현, 실현은 병렬적으로 이루질 수 있다. 따라서 구현자들은 기다리지 않아도 된다.
구현은 명확히 정의된 비용과 성능목표만 있다면 실행될 수 있고, 설계와 실혐은 그동안 물리적인 구성을 준비하거나 문서화를 진행한다.
개념적 무결성을 유지하는 동시에 시스템 개발이 분업화되면 작업 시간이 길 것 같지만, 오히려 짧다.  
```
