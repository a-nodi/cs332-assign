# Summery of clean code 
```
이 글은 로버트 C.마틴의 클린 코드의 요약이다.
책의 구조가 탑다운으로 이루어져있고, 소챕터가 격언의 형식으로 소챕터 내용의 핵심을 뚫고 있다.  
소챕터명을 중심으로 디테일한 부분을 기억하기 쉽도록 요약할 것이다.
```

## Chapter 2: 의미 있는 이름
```
이 챕터는 변수, 함수, 클래스, 파일명등 소프트웨어를 개발하는 중 작명할 때 해야 할 행동들을 설명하고 있다. 
```

### 2.2. 의도를 분명히 밝혀라
```
의도가 분명한 이름은 그렇지 않은 이름을 사용하는 코드보다 훨씬 이해하기 쉽다.
```

### 2.3. 그릇된 정보를 피하라
```
불분명하거나 그릇된 정보를 변수명에 넣지 말아야한다.
```

### 2.4. 의미 있게 구분하라
```
읽는 사람이 차이를 쉽게 알 수 있도록 이름을 지어야한다. 
```

### 2.5. 발음하기 쉬운 이름을 사용하라
```
발음하기 쉬운 이름을 사용해야 소프트웨어 개발자간의 소통이 원활하다.
```

### 2.6. 검색하기 쉬운 이름을 사용하라
```
변수 및 상수에 정보를 포함하는 이름을 붙여 검색하기 쉽도록 해야한다. 
```

### 2.7. 인코딩을 피하라
```
필요없는 정보의 인코딩을 이름에 포함하지 마라
- 헝가리안 표기법 (변수 타입 접두어)
- 멤버 변수 접두어 (m 접두어)
- 인터페이스 클래스와 구현 클래스 (I 접두어)
```

### 2.8. 자신의 기억력을 자랑하지 마라
```
다른 사람도 이해할 수 있도록 이름을 지어야 한다.
```

### 2.9. 클래스 이름
```
클래스명 및 객체명은 명사 혹은 명사구로 짓는 것을 추천한다.
```

### 2.10. 메소드 이름
```
메소드명은 동사나 동사구로 짓는 것을 추천한다. 
```

### 2.11. 기발한 이름은 피하라
```
농담이 섞인 이름은 문화가 다른 사람에게 의도가 제대로 전달되지 않으므로 가급적 사용하지 않는 것이 좋다.
```

### 2.12. 개념 하나에 단어 하나를 사용하라
```
개념별로 독자적으로 이름을 지어야하고 일관적인 형식을 갖춰야 읽는 사람이 바로 이해하기 편하다.
```

### 2.13. 말장난을 하지 마라
```
일관성에 너무 집중해 맥락에 벗어날 정도로 비슷한 이름을 짓지 말아야 한다.
```

### 2.14. 해법 영역에서 사용하는 이름을 사용하라
```
기술적으로 필요한 경우 문제영역의 이름을 사용하고, 그 이외에는 해법 영역의 이름을 사용해야 한다.
```

### 2.15. 문제 영역과 관련 있는 이름을 사용하라
```
해법영역에서 가져올 마땅한 이름이 없는 경우 문제 영역에서 이름을 가져온다.
```

### 2.16. 의미 있는 맥락을 추가하라
```
코드의 맥락을 부여하기 위해 이름에 필요한 단어를 추가하면 좋다.
```

### 2.17. 불필요한 맥락을 없애라
```
맥락을 유지하기 위해 불필요한 단어를 사용하여 이름을 지으면 안 된다.
```


## Chapter 3: 함수
```
이 챕터는 함수를 효율적이고 가독성 있게 짜는 방법을 설명하고 있다.
```

### 3.1. 작게 만들어라
```
함수는 짧을수록 의미가 명백해진다.
```

### 3.2. 한 가지만 해라
```
함수는 해당하는 추상화 수준에서 한 가지 기능만 하도록 작성되어야 한다.
```

### 3.3. 함수 당 추상화 수준은 하나로
```
함수 내에서 실행되는 다른 작은 함수들은 모두 동일한 추상화 수준이 되도록 구현되어야 한다.
- 내려가기 규칙: 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
```

### 3.4. Switch 문
```
다형성을 사용하는 경우에만 Switch문을 사용하는 것이 좋다.
```

### 3.5. 서술적인 이름을 사용하라 
```
길더라도 서술적인 이름은 함수의 설계를 명확히 한다.
```

### 3.6. 함수 인수
```
함수 인수는 0, 1, 2개가 적당하고, 3개는 피하며, 4개는 특별한 이유가 있어야한다.
- 많이 쓰는 단항 형식: 인수로 질문을 던지거나 인수를 변환, 이벤트 등에 사용한다.
- 플래그 인수: Boolean을 인수로 넘기는 것은 좋지 않다.
- 이항 함수: 나쁘지 않지만 되도록 단항함수를 사용하는 것이 좋다.
- 삼항 함수: 세 개의 항을 사용할 경우 그만한 가치가 있을 때만 사용한다.
- 인수 객체: 객체를 이용하여 관련된 인수를 묶어 보내는 것이 좋다.
- 인수 목록: 인수 갯수가 가변적인 함수도 필요하다면 사용할 수 있다.
- 동사와 키워드: 동사 + 키워드 형식으로 함수명을 지으면 인수 순서 및 의도를 제대로 표현할 수 있다.
```

### 3.7. 부수 효과를 일으키지 마라
```
함수가 부수효과를 일으키면 하나의 기능만 있는 것이 아니므로 가급적 피한다.
- 출력 인수: 출력 인수 대신 함수가 속한 객체의 상태를 변경하도록 하는 것이 좋다.
```

### 3.8. 명령과 조회를 분리하라
```
함수는 뭔가 수행하거나, 뭔가에 답하거나 둘 중 하나만 해야한다. 그렇지 않은 경우 함수명이 혼란을 일으키는 경우가 있다.
```

### 3.9. 오류 코드보다 예외를 사용하라 
```
오류 코드 반환은 명령함수의 명령/조회 분리 규칙을 위반한다.
오류 코드대신 예외처리를 사용하면 오류 처리가 원래코드와 분리된다. 
- Try/Catch 블록 뽑아내기: 별도 함수로 예외처리를 해주면 좋다.
- 오류 처리도 한 가지 작업이다: 오류 처리함수는 오류만 처리해아한다.
```

### 3.10. 반복하지 마라
```
반복되는 코드를 제거해야 한다.
```

### 3.11. 구조적 프로그래밍
```
함수가 아주 큰경우 모든 함수와 함수 내 블록에서는 입구와 출구가 하나만 존재하도록 설계하면 효율적이다. 함수가 작은 경우는 그렇지 않을 수 있다.

```

### 3.12. 함수를 어떻게 짜죠?
```
소프트웨어 작성은 글쓰기와 비슷하다. 초고를 작성하면 이를 다듬어 가독성과 효율성있게 만들어야한다.
```

## Chapter 4: 주석
```
이 챕터는 주석을 효율적이고 효과적으로 작성하는 법에 대해 다룬다.
```

### 4.1. 주석은 나쁜 코드를 보완하지 못한다.
```
코드에 주석을 달아 설명하기보다 주석이 필요하지 않은 더 나은 코드를 작성해야한다.
```

### 4.2. 코드로 의도를 표현하라.
```
주석으로 달려는 설명을 함수로 만들어 표현하면 좋다.
```

### 4.3. 좋은 주석 
```
사실 최선의 주석은 없는 주석이지만 차선의 주석을 아래에 설명한다.
```


#### 4.3.1. 법적인 주석
```
법적인 이유(저작권, 소유권)로 표기하는 주석은 필요하다.
```

#### 4.3.2. 정보를 제공하는 주석
```
주석으로 기본적인 정보를 제공하면 편리하나, 이는 함수와 클래스로 대체할 수 있다.
```

#### 4.3.3. 의도를 설명하는 주석
```
구현 결정의 의도를 설명하는 경우도 있다. 이 함수와 클래스 및 코드 구조의 개선으로 대체할 수 있다.
```

#### 4.3.4. 의미를 명료하게 밝히는 주석
```
코드 개선을 통해 인수나 반환값의 자체를 명확하게 만들 수 있지만 코드 수정이 불가한 경우 주석으로 표현해도 괜찮다.
```

#### 4.3.5. 결과를 경고하는 주석
```
부하를 거는 테스트 케이스 등 결과를 경고해야할 경우 주석은 매우 합리적인 선택이다. 
```

#### 4.3.6. TODO 주석
```
앞으로 할 일을 TODO 주석으로 남기면 편하다. 코드 기능추가/에러수정 등 다양한 경우에 사용가능하다.
```

#### 4.3.7. 중요성을 강조하는 주석
```
겉보기에 중요하지 않은 코드를 강조해야할 경우 주석이 이를 표기하기에 편리하다.
```

#### 4.3.8. 공개 API의 docs
```
공개 API에 설명이 잘 되어있다면(docs 등으로 설명) 매우 좋다.
```

### 4.4. 나쁜 주석
```
대다수의 주석은 이에 속한다.
```

#### 4.4.1. 주절거리는 주석
```
특별한 의미가 없다면 주석을 달지 않아야 한다.
```

#### 4.4.2. 같은 이야기를 중복하는 주석
```
코드 내용을 반복하여 주석을 달 필요는 없다.
```

#### 4.4.3. 오해할 여지가 있는 주석
```
잘못 된 정보를 포함하는 주석은 다른 프로그래머가 코드를 사용하기 힘들게 만든다.
```

#### 4.4.4. 의무적으로 다는 주석
```
의무적으로 달은 필요없는 주석은 코드의 가독성을 떨어뜨리고 잘못된 정보를 제공할 가능성을 높힌다.
```

#### 4.4.5. 이력을 기록하는 주석
```
코드 변경 이력을 기록하는 프로그램이 이미 존재하므로 더 이상 이런 주석을 달 필요가 없다.
```

#### 4.4.6. 있으나 마나 한 주석
```
당연한 사실을 언급하며 새로운 정보를 주지 못하는 주석은 필요없다.
```

#### 4.4.7. 무서운 잡음
```
쓸데없는 주석 작성을 위해 복사 붙여넣기를 하다가 오타를 낼 수 있다.
```

#### 4.4.8. 함수나 변수로 표현할 수 있다면 주석을 달지 마라
```
함수명과 변수명으로 의도를 표현하는 것이 훨씬 바람직하다.
```

#### 4.4.9. 위치를 표시하는 주석
```
배너등의 주석은 적당히 있으면 좋지만 가독성을 떨어뜨릴 수 있다.
```

#### 4.4.10. 닫는 괄호에 다는 주석
```
작고 캡슐화된 함수에 주석의 끝을 표기하는 것은 불필요하다.
```

#### 4.4.11. 공로를 돌리거나 저자를 표시하는 주석
```
코드 변경 이력을 기록하는 프로그램이 저자를 저장하므로 이런 주석 또한 필요없다.
```

#### 4.4.12. 주석으로 처리한 코드 
```
주석처리한 코드는 언젠가 재사용할 것을 내포할 수 있으므로 실제로 필요 없음에도 주석이 쌓이는 결과를 초래한다.
코드를 그냥 삭제하는 편이 낫다.
```

#### 4.4.13. HTML 주석
```
HTML 태그를 이용하여 주석을 달면 가독성이 매우 떨어진다.
```

#### 4.4.14. 전역 정보
```
주석은 설명하고자 하는 코드 근처에 있어야한다. 시스템 전반의 정보를 주석에 통쨰로 기술하면 안 된다.
```

#### 4.4.15. 너무 많은 정보
```
주석에 TMI를 적을 필요는 없다.
```

#### 4.4.16. 모호한 관계
```
또다른 설명을 요구하는 (용어의 모호함 등) 주석은 좋은 주석이 아니다.
```

#### 4.4.17. 함수 헤더
```
주석으로 헤더를 붙여 함수를 설명할 바에 함수명을 잘 지어 직관적으로 정보를 전달하는 것이 낫다.
```

#### 4.4.18. 비공개 코드에서 docs
```
공개하지 않을 코드의 docs는 코드를 산만하게 만들 뿐이다.
```

## Chapter 7: 오류 처리
```
이 챕터는 코드의 오류 처리를 최대한 가독성 있고 효율적으로 하는 방법을 설명한다.
```

### 7.1. 오류코드보다 예외를 사용하라
```
예외처리는 오류코드 반환보다 훨씬 가독성을 높힌다. 예외처리시 원 기능을 구현한 코드와 오류를 처리하는 부분이 분리되기 떄문이다.
```

### 7.2. Try-Catch-Finally 문부터 작성하라
```
try-catch-finally 구조로 예외를 처리하고 예외 유형을 좁혀가며 리펙토링을 할 수 있다.
```

### 7.3. 미확인 예외를 사용하라
```
확인된 예외는 OCP(Open Closed Principle)를 깨뜨리는 경우가 있다. 이를 막기 위해 미확인 예외를 사용할 수 있다.ㅎ
```

### 7.4. 예외에 의미를 제공하라
```
오류메시지를 통해 예외에 대한 정보를 전달하면 예외를 파악하기 쉬워진다.
```

### 7.5. 호출자를 고려해 예외 클래스를 정의하라 
```
예외를 클래스로 감싸 테스트 코딩에 용이하게하고 코드-라이브러리간 의존성을 줄일 수 있다.
```

### 7.6. 정상 흐름을 정의하라
```
특수사례객체를 이용하면 예외사항을 캡슐화하여 관리할 수 있다.
```

### 7.7. null을 반환하지 마라
```
메소드에 오류가 발생했다면 null 반환 대신 예외처리 혹은 특수사례객체를 반환하는 방식을 고려해야한다.
null반환은 null 검사 요구 및 NullPointerExceptions 발생 확률이 높아진다.
```

### 7.8. null을 전달하지 마라
```
null을 인수로 전달하는 코드는 인수처리에 예외처리를 해야하는 문제를 일으킨다. 애초에 null을 전달하지 않으면 해결되는 문제이다.ㄴ
```

### 7.9. 결론
```
오류처리와 프로그램 논리를 잘 분리하면 가독성 및 코드 유지보수성이 높아진다.
```